/*
 * This file is generated by jOOQ.
 */
package com.task.infra.database.jooq.tables


import com.task.infra.database.jooq.Public
import com.task.infra.database.jooq.indexes.IDX_TASK_DEFINITIONS_IS_DELETED
import com.task.infra.database.jooq.indexes.IDX_TASK_DEFINITIONS_OWNER
import com.task.infra.database.jooq.indexes.IDX_TASK_DEFINITIONS_SCHEDULED_END_TIME
import com.task.infra.database.jooq.indexes.IDX_TASK_DEFINITIONS_SCHEDULED_START_TIME
import com.task.infra.database.jooq.indexes.IDX_TASK_DEFINITIONS_SCHEDULE_TYPE
import com.task.infra.database.jooq.indexes.IDX_TASK_DEFINITIONS_SCOPE
import com.task.infra.database.jooq.keys.TASK_DEFINITIONS_PKEY
import com.task.infra.database.jooq.keys.TASK_DEFINITIONS__TASK_DEFINITIONS_OWNER_MEMBER_ID_FKEY
import com.task.infra.database.jooq.tables.records.TaskDefinitionsRecord

import java.time.LocalDate
import java.time.OffsetDateTime
import java.util.UUID
import java.util.function.Function

import kotlin.collections.List

import org.jooq.Check
import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.Index
import org.jooq.Name
import org.jooq.Record
import org.jooq.Records
import org.jooq.Row13
import org.jooq.Schema
import org.jooq.SelectField
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.UniqueKey
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl


/**
 * タスク定義（カタログ）
 */
@Suppress("UNCHECKED_CAST")
open class TaskDefinitions(
    alias: Name,
    child: Table<out Record>?,
    path: ForeignKey<out Record, TaskDefinitionsRecord>?,
    aliased: Table<TaskDefinitionsRecord>?,
    parameters: Array<Field<*>?>?
): TableImpl<TaskDefinitionsRecord>(
    alias,
    Public.PUBLIC,
    child,
    path,
    aliased,
    parameters,
    DSL.comment("タスク定義（カタログ）"),
    TableOptions.table()
) {
    companion object {

        /**
         * The reference instance of <code>public.task_definitions</code>
         */
        val TASK_DEFINITIONS: TaskDefinitions = TaskDefinitions()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<TaskDefinitionsRecord> = TaskDefinitionsRecord::class.java

    /**
     * The column <code>public.task_definitions.id</code>. タスク定義ID（UUID）
     */
    val ID: TableField<TaskDefinitionsRecord, UUID?> = createField(DSL.name("id"), SQLDataType.UUID.nullable(false).defaultValue(DSL.field(DSL.raw("uuid_generate_v4()"), SQLDataType.UUID)), this, "タスク定義ID（UUID）")

    /**
     * The column <code>public.task_definitions.name</code>. タスク名
     */
    val NAME: TableField<TaskDefinitionsRecord, String?> = createField(DSL.name("name"), SQLDataType.VARCHAR(200).nullable(false), this, "タスク名")

    /**
     * The column <code>public.task_definitions.description</code>. タスクの説明・実行方法
     */
    val DESCRIPTION: TableField<TaskDefinitionsRecord, String?> = createField(DSL.name("description"), SQLDataType.CLOB, this, "タスクの説明・実行方法")

    /**
     * The column <code>public.task_definitions.scope</code>. スコープ（FAMILY:
     * 家族全体、PERSONAL: 個人）
     */
    val SCOPE: TableField<TaskDefinitionsRecord, String?> = createField(DSL.name("scope"), SQLDataType.VARCHAR(20).nullable(false), this, "スコープ（FAMILY: 家族全体、PERSONAL: 個人）")

    /**
     * The column <code>public.task_definitions.owner_member_id</code>.
     * 所有者（PERSONALの場合のみ）
     */
    val OWNER_MEMBER_ID: TableField<TaskDefinitionsRecord, UUID?> = createField(DSL.name("owner_member_id"), SQLDataType.UUID, this, "所有者（PERSONALの場合のみ）")

    /**
     * The column <code>public.task_definitions.schedule_type</code>.
     * スケジュールタイプ（RECURRING: 定期、ONE_TIME: 単発）
     */
    val SCHEDULE_TYPE: TableField<TaskDefinitionsRecord, String?> = createField(DSL.name("schedule_type"), SQLDataType.VARCHAR(20).nullable(false), this, "スケジュールタイプ（RECURRING: 定期、ONE_TIME: 単発）")

    /**
     * The column <code>public.task_definitions.one_time_deadline</code>.
     * 期限（ONE_TIMEの場合のみ）
     */
    val ONE_TIME_DEADLINE: TableField<TaskDefinitionsRecord, LocalDate?> = createField(DSL.name("one_time_deadline"), SQLDataType.LOCALDATE, this, "期限（ONE_TIMEの場合のみ）")

    /**
     * The column <code>public.task_definitions.version</code>. 楽観ロック用バージョン
     */
    val VERSION: TableField<TaskDefinitionsRecord, Int?> = createField(DSL.name("version"), SQLDataType.INTEGER.nullable(false).defaultValue(DSL.field(DSL.raw("1"), SQLDataType.INTEGER)), this, "楽観ロック用バージョン")

    /**
     * The column <code>public.task_definitions.is_deleted</code>. 論理削除フラグ
     */
    val IS_DELETED: TableField<TaskDefinitionsRecord, Boolean?> = createField(DSL.name("is_deleted"), SQLDataType.BOOLEAN.nullable(false).defaultValue(DSL.field(DSL.raw("false"), SQLDataType.BOOLEAN)), this, "論理削除フラグ")

    /**
     * The column <code>public.task_definitions.created_at</code>. 作成日時
     */
    val CREATED_AT: TableField<TaskDefinitionsRecord, OffsetDateTime?> = createField(DSL.name("created_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false).defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.TIMESTAMPWITHTIMEZONE)), this, "作成日時")

    /**
     * The column <code>public.task_definitions.updated_at</code>. 更新日時
     */
    val UPDATED_AT: TableField<TaskDefinitionsRecord, OffsetDateTime?> = createField(DSL.name("updated_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false).defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.TIMESTAMPWITHTIMEZONE)), this, "更新日時")

    /**
     * The column <code>public.task_definitions.scheduled_start_time</code>.
     * 予定開始時刻
     */
    val SCHEDULED_START_TIME: TableField<TaskDefinitionsRecord, OffsetDateTime?> = createField(DSL.name("scheduled_start_time"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false), this, "予定開始時刻")

    /**
     * The column <code>public.task_definitions.scheduled_end_time</code>.
     * 予定終了時刻
     */
    val SCHEDULED_END_TIME: TableField<TaskDefinitionsRecord, OffsetDateTime?> = createField(DSL.name("scheduled_end_time"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false), this, "予定終了時刻")

    private constructor(alias: Name, aliased: Table<TaskDefinitionsRecord>?): this(alias, null, null, aliased, null)
    private constructor(alias: Name, aliased: Table<TaskDefinitionsRecord>?, parameters: Array<Field<*>?>?): this(alias, null, null, aliased, parameters)

    /**
     * Create an aliased <code>public.task_definitions</code> table reference
     */
    constructor(alias: String): this(DSL.name(alias))

    /**
     * Create an aliased <code>public.task_definitions</code> table reference
     */
    constructor(alias: Name): this(alias, null)

    /**
     * Create a <code>public.task_definitions</code> table reference
     */
    constructor(): this(DSL.name("task_definitions"), null)

    constructor(child: Table<out Record>, key: ForeignKey<out Record, TaskDefinitionsRecord>): this(Internal.createPathAlias(child, key), child, key, TASK_DEFINITIONS, null)
    override fun getSchema(): Schema? = if (aliased()) null else Public.PUBLIC
    override fun getIndexes(): List<Index> = listOf(IDX_TASK_DEFINITIONS_IS_DELETED, IDX_TASK_DEFINITIONS_OWNER, IDX_TASK_DEFINITIONS_SCHEDULE_TYPE, IDX_TASK_DEFINITIONS_SCHEDULED_END_TIME, IDX_TASK_DEFINITIONS_SCHEDULED_START_TIME, IDX_TASK_DEFINITIONS_SCOPE)
    override fun getPrimaryKey(): UniqueKey<TaskDefinitionsRecord> = TASK_DEFINITIONS_PKEY
    override fun getReferences(): List<ForeignKey<TaskDefinitionsRecord, *>> = listOf(TASK_DEFINITIONS__TASK_DEFINITIONS_OWNER_MEMBER_ID_FKEY)

    private lateinit var _members: Members

    /**
     * Get the implicit join path to the <code>public.members</code> table.
     */
    fun members(): Members {
        if (!this::_members.isInitialized)
            _members = Members(this, TASK_DEFINITIONS__TASK_DEFINITIONS_OWNER_MEMBER_ID_FKEY)

        return _members;
    }

    val members: Members
        get(): Members = members()
    override fun getChecks(): List<Check<TaskDefinitionsRecord>> = listOf(
        Internal.createCheck(this, DSL.name("chk_onetime_deadline"), "(((((schedule_type)::text = 'RECURRING'::text) AND (one_time_deadline IS NULL)) OR (((schedule_type)::text = 'ONE_TIME'::text) AND (one_time_deadline IS NOT NULL))))", true),
        Internal.createCheck(this, DSL.name("chk_personal_owner"), "(((((scope)::text = 'FAMILY'::text) AND (owner_member_id IS NULL)) OR (((scope)::text = 'PERSONAL'::text) AND (owner_member_id IS NOT NULL))))", true),
        Internal.createCheck(this, DSL.name("chk_scheduled_time_range"), "((scheduled_start_time < scheduled_end_time))", true),
        Internal.createCheck(this, DSL.name("task_definitions_schedule_type_check"), "(((schedule_type)::text = ANY ((ARRAY['RECURRING'::character varying, 'ONE_TIME'::character varying])::text[])))", true),
        Internal.createCheck(this, DSL.name("task_definitions_scope_check"), "(((scope)::text = ANY ((ARRAY['FAMILY'::character varying, 'PERSONAL'::character varying])::text[])))", true)
    )
    override fun `as`(alias: String): TaskDefinitions = TaskDefinitions(DSL.name(alias), this)
    override fun `as`(alias: Name): TaskDefinitions = TaskDefinitions(alias, this)
    override fun `as`(alias: Table<*>): TaskDefinitions = TaskDefinitions(alias.getQualifiedName(), this)

    /**
     * Rename this table
     */
    override fun rename(name: String): TaskDefinitions = TaskDefinitions(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): TaskDefinitions = TaskDefinitions(name, null)

    /**
     * Rename this table
     */
    override fun rename(name: Table<*>): TaskDefinitions = TaskDefinitions(name.getQualifiedName(), null)

    // -------------------------------------------------------------------------
    // Row13 type methods
    // -------------------------------------------------------------------------
    override fun fieldsRow(): Row13<UUID?, String?, String?, String?, UUID?, String?, LocalDate?, Int?, Boolean?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?> = super.fieldsRow() as Row13<UUID?, String?, String?, String?, UUID?, String?, LocalDate?, Int?, Boolean?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?>

    /**
     * Convenience mapping calling {@link SelectField#convertFrom(Function)}.
     */
    fun <U> mapping(from: (UUID?, String?, String?, String?, UUID?, String?, LocalDate?, Int?, Boolean?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?) -> U): SelectField<U> = convertFrom(Records.mapping(from))

    /**
     * Convenience mapping calling {@link SelectField#convertFrom(Class,
     * Function)}.
     */
    fun <U> mapping(toType: Class<U>, from: (UUID?, String?, String?, String?, UUID?, String?, LocalDate?, Int?, Boolean?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?, OffsetDateTime?) -> U): SelectField<U> = convertFrom(toType, Records.mapping(from))
}
